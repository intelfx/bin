#!/bin/bash

set -eo pipefail
shopt -s lastpipe

log() {
	echo ":: $*" >&2
}

err() {
	echo "E: $*" >&2
}

die() {
	err "$@"
	exit 1
}

usage() {
	if (( $# )); then
		echo "${0##*/}: $*" >&2
		echo >&2
	fi
	_usage >&2
	exit 1
}

_usage() {
	cat <<EOF
Usage: ${0##*/} [-c|--cached]

Interactively edit the last commit, or staged changes (with -c/--cached).
EOF
}


#
# args
#

if args=$(getopt -o 'hc' --long 'help,cached' -n "${0##*/}" -- "$@"); then
	eval set -- "$args"
else
	usage
fi
unset args

unset ARG_CACHED
while :; do
	case "$1" in
	-c|--cached) ARG_CACHED=1 ;;
	-h|--help) usage ;;
	--) shift; break ;;
	*) die "getopt error" ;;
	esac
	shift
done

case "$#" in
0) ;;
*) usage "unexpected positional arguments" ;;
esac


#
# main
#

#
# XXX: this is implemented by playing games with index, so make sure that
#      there are no interfering changes (otherwise they will get mixed up
#      with the edit target).
#

if ! git diff --ignore-submodules --quiet --exit-code; then
	die "working tree is unclean (unstaged changes present), aborting"
fi

if ! git diff --ignore-submodules --cached --quiet --exit-code; then
	if ! [[ ${ARG_CACHED+set} ]]; then
		die "index is unclean (staged changes present), aborting"
	fi
else
	if [[ ${ARG_CACHED+set} ]]; then
		die "index is clean (no staged changes), nothing to do"
	fi
fi

cleanup() {
	git reset
}
trap cleanup EXIT

TOP_DIR="$(git rev-parse --show-toplevel)"
if [[ ${ARG_CACHED+set} ]]; then
	git diff 'HEAD' --ignore-submodules --cached --name-only -z \
	| sponge \
	| {
		git reset 'HEAD' -- "$TOP_DIR" </dev/null
		git add --all --force --intent-to-add --pathspec-from-file=- --pathspec-file-nul
	}
	git add --edit
else
	git reset 'HEAD^' -- "$TOP_DIR"
	git diff 'HEAD^..' --ignore-submodules --name-only -z \
		| git add --all --force --intent-to-add --pathspec-from-file=- --pathspec-file-nul
	git add --edit
	git commit --amend --no-edit "$@"
fi
