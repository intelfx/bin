#!/bin/bash

set -eo pipefail
shopt -s lastpipe
shopt -s extglob

# shellcheck source=../lib/lib.sh
. lib.sh

#
# tmuxpipe - run shell pipelines with each command in a separate tmux pane
#
# This tool helps disentangle multiple progress outputs from large shell pipelines
# where multiple commands write to the tty with cursor positioning sequences or \r,
# stepping onto each other.
#
# Each pipeline step runs in its own tmux pane, with a monitor pane showing overall
# progress. Data flows between steps via named pipes (FIFOs).
#
# Usage:
#   tmuxpipe cmd1 arg1 arg2 \! cmd2 arg1 \! cmd3 arg1 arg2 arg3
#
# Commands are separated by `!` (which must be escaped or quoted in the shell).
#
# Architecture:
#   - Main process: initial setup, spawns tmux in background, spawns all panes, attaches, cleans up
#   - Monitor pane: shows pipeline status, waits for completion, prompts to exit, kills the server
#   - Step panes: execute commands with stdin/stdout connected to each other via FIFOs
#
# Future work:
#   - Support attaching to an existing tmux session instead of creating a new one
#

# --- Constants ---
readonly TMUXPIPE_REEXEC_VAR="_TMUXPIPE_REEXEC"
readonly TMUXPIPE_WORKDIR_VAR="_TMUXPIPE_WORKDIR"
readonly TMUXPIPE_STEP_VAR="_TMUXPIPE_STEP"

# --- Usage ---
_usage() {
	cat <<-EOF
	Usage: $LIB_ARGV0 [OPTIONS] CMD [ARGS...] [! CMD [ARGS...]]...

	Run a shell pipeline with each command in a separate tmux pane.

	Options:
	  -h, --help     Show this help message
	  -d, --debug    Enable debug output

	Arguments:
	  CMD [ARGS...]  Command and its arguments
	  !              Pipeline separator (must be escaped: \\!)

	Example:
	  $LIB_ARGV0 zfs send -v pool@snap \\! zstd -v \\! pv \\! ssh host 'cat > file'

	Notes:
	  - If only one command is given (no '!' separators), it runs directly without tmux.
	  - The first command reads from stdin if not a terminal; otherwise from /dev/null.
	  - The last command writes into a buffer, which is then copied to overall stdout.
	  - Press any key in the monitor pane to exit after the pipeline completes.
	EOF
}

# --- Argument parsing ---
declare -A ARGS=(
	[--help]="ARG_HELP"
	[--debug]="ARG_DEBUG"
	[--]="ARG_REMAINDER"
)

# --- Helper functions ---

# Serialize an array to a file using declare -p
serialize_array() {
	local file="$1"
	shift
	local -a arr=( "$@" )
	declare -p arr >"$file"
}

# Deserialize an array from a file
# Returns the array via a nameref
deserialize_array() {
	local file="$1"
	declare -n _out="$2"
	local arr  # declare -p will define this
	# shellcheck disable=SC1090
	source "$file"
	_out=( "${arr[@]}" )
}

# Get the number of pipeline steps
get_step_count() {
	local count=0
	while [[ -d "$WORKDIR/steps/$count" ]]; do
		(( ++count ))
	done
	echo "$count"
}

# Wait for all panes to exit using tmux wait-for
# This is more efficient than polling
wait_for_panes() {
	local count="$1"

	# Wait for each step's completion channel
	local i
	for (( i = 0; i < count; i++ )); do
		# Use tmux wait-for to block until signaled
		# Each pane will signal "step-$i-done" when complete
		_tmux wait-for "step-$i-done"
	done
}

# Get the first non-zero exit code, or 0 if all succeeded
# (mimics shell pipeline behavior: return rightmost non-zero, but we use leftmost for clarity)
get_pipeline_exit_code() {
	local count
	count="$(get_step_count)"
	local i code
	for (( i = 0; i < count; i++ )); do
		if [[ -f "$WORKDIR/steps/$i/exitcode" ]]; then
			code="$(<"$WORKDIR/steps/$i/exitcode")"
			if (( code != 0 )); then
				echo "$code"
				return
			fi
		else
			# Pane was killed without writing exit code
			echo "137"  # 128 + SIGKILL(9)
			return
		fi
	done
	echo "0"
}

# Format a command array for display (truncate if too long)
format_cmd() {
	local -a cmd=( "$@" )
	local str="${cmd[*]}"
	if (( ${#str} > 60 )); then
		str="${str:0:57}..."
	fi
	echo "$str"
}

# --- Execution modes ---

# Mode: Execute a pipeline step (reexec mode)
run_step() {
	_tmux() {
		tmux "$@" 2>/dev/null || true
	}

	local step="$1"
	local stepdir="$WORKDIR/steps/$step"

	local count
	count="$(get_step_count)"

	# Set pane to remain on exit so user can see output
	_tmux set-option -t "$TMUX_PANE" remain-on-exit on

	# Deserialize command
	local -a cmd
	deserialize_array "$stepdir/command" cmd

	# Determine stdin/stdout for this step
	local stdin_source stdout_dest
	if (( step == 0 )); then
		# First step: check if we have external stdin
		if [[ -e "$WORKDIR/stdin" ]]; then
			stdin_source="$WORKDIR/stdin"
		else
			# No external stdin, use /dev/null
			stdin_source="/dev/null"
		fi
	else
		# Read from previous step's FIFO
		stdin_source="$WORKDIR/steps/$((step - 1))/pipe"
	fi

	if (( step == count - 1 )); then
		# Last step: check if we have somewhere to write stdout to
		if [[ -e "$WORKDIR"/stdout ]]; then
			# Buffer to the final stdout location
			stdout_dest="$WORKDIR/stdout"
		else
			# Write to the pane's terminal normally
			stdout_dest=""  # empty means don't redirect
		fi
	else
		# Write to this step's FIFO
		stdout_dest="$stepdir/pipe"
	fi

	# Signal handler to write exit code even on signals
	local rc
	# shellcheck disable=SC2329
	_cleanup() {
		# Untrap everything to avoid repeated cleanup
		trap - HUP INT QUIT ABRT PIPE TERM EXIT
		# Write exit code
		echo "$rc" >"$stepdir/exitcode"
		# Signal completion via tmux wait-for
		_tmux wait-for -S "step-$step-done"
	}
	# shellcheck disable=SC2329
	_exit() {
		# if by some chance the child's exit code is not set (e.g. the
		# control process was killed and we are in the signal handler),
		# use the last exit code instead of the child's exit code
		rc="${rc:-$?}"
		_cleanup
		if (( rc > 128 )); then
			# either the child process exited with a signal, or we were killed with it
			# we cannot just exit with $rc because that will not be a true WIFSIGNALED
			# so kill ourselves with the same signal
			kill -"$(( rc - 128 ))" "$$"
		fi
		exit "$rc"
	}
	# XXX: an EXIT trap is not enough to catch non-zero codes from signals,
	#      so we need a dedicated handler for signals
	trap _exit HUP INT QUIT ABRT PIPE TERM EXIT

	# Print the command being executed (similar to set -x output)
	echo "─────────────────────────────────────────────────" >&2
	echo "+ ${cmd[*]}" >&2
	echo "─────────────────────────────────────────────────" >&2
	echo >&2

	# do not die on non-zero exit codes, we handle them ourselves
	set +e

	# Run with proper redirections
	# NB: opening FIFOs for writing blocks until it is open for reading
	#     this specific ordering causes all commands to start at the same time
	#     (everything blocks until the last step opens its FIFO for reading)
	if [[ -n "$stdout_dest" ]]; then
		"${cmd[@]}" >"$stdout_dest" <"$stdin_source"
	else
		"${cmd[@]}" <"$stdin_source"
	fi

	rc=$?

	# EXIT trap will handle writing exitcode and signaling
	exit "$rc"
}

# Mode: Monitor pane (waits for all steps to complete, then prompts)
run_monitor() {
	_tmux() {
		tmux "$@" 2>/dev/null || true
	}

	echo "╔══════════════════════════════════════════════════════════════╗"
	echo "║              Pipeline Monitor - tmuxpipe                     ║"
	echo "╚══════════════════════════════════════════════════════════════╝"
	echo
	echo "Waiting for all commands to complete..."
	echo

	local count
	count="$(get_step_count)"

	# Show the pipeline
	local i
	for (( i = 0; i < count; i++ )); do
		local -a cmd
		deserialize_array "$WORKDIR/steps/$i/command" cmd
		printf "  [%d] %s\n" "$i" "$(format_cmd "${cmd[@]}")"
	done
	echo

	# Wait for all panes to complete
	wait_for_panes "$count"

	# Show summary
	echo
	echo "════════════════════════════════════════════════════════════════"
	echo "All commands completed."
	echo

	local any_failed=0
	local -a cmd
	local code status_icon
	for (( i = 0; i < count; i++ )); do
		deserialize_array "$WORKDIR/steps/$i/command" cmd
		if [[ -f "$WORKDIR/steps/$i/exitcode" ]]; then
			code="$(<"$WORKDIR/steps/$i/exitcode")"
		else
			code="???"
		fi

		if [[ "$code" == "0" ]]; then
			status_icon="✓"
		else
			status_icon="✗"
			any_failed=1
		fi

		printf "  %s [%d] exit %-3s │ %s\n" "$status_icon" "$i" "$code" "$(format_cmd "${cmd[@]}")"
	done

	echo
	if (( any_failed )); then
		echo "⚠  Pipeline FAILED (see above for exit codes)"
	else
		echo "✓  Pipeline completed successfully"
	fi
	echo

	read -r -s -n1 -p "Press any key to exit..."
	echo

	# Kill the tmux server
	_tmux kill-server
}

# Mode: Main orchestrator
run_main() {
	local -a args=( "$@" )

	if (( ${#args[@]} == 0 )); then
		usage "No commands specified"
	fi

	# Parse arguments into pipeline steps
	local -a steps=()
	local -a current_cmd=()
	local arg

	for arg in "${args[@]}"; do
		if [[ "$arg" == "!" ]]; then
			if (( ${#current_cmd[@]} == 0 )); then
				die "Empty command before '!'"
			fi
			steps+=( "$(declare -p current_cmd)" )
			current_cmd=()
		else
			current_cmd+=( "$arg" )
		fi
	done

	# Don't forget the last command
	if (( ${#current_cmd[@]} == 0 )); then
		die "Empty command at end of pipeline"
	fi
	steps+=( "$(declare -p current_cmd)" )

	local step_count="${#steps[@]}"
	log "Parsed $step_count pipeline step(s)"

	# Special case: single command - just run it directly without tmux
	if (( step_count == 1 )); then
		log "Single command, running directly..."
		eval "${steps[0]}"
		exec "${current_cmd[@]}"
	fi

	# Create temporary working directory
	WORKDIR="$(mktemp -d --tmpdir "tmuxpipe.XXXXXXXXXX")"
	dbg "Working directory: $WORKDIR"

	# Create tmux socket path
	SOCKET="$WORKDIR/tmux.sock"
	dbg "tmux socket: $SOCKET"

	# Generate a unique tmux session name (for no particular reason, just in case)
	local target="tmuxpipe-$$"

	# Define a wrapper to run tmux commands on our socket, squelching stderr and errors
	_tmux() {
		tmux -S "$SOCKET" "$@" 2>/dev/null || true
	}

	# Cleanup function
	# shellcheck disable=SC2329
	_cleanup() {
		# Kill tmux server if still running
		if [[ -S "$SOCKET" ]]; then
			_tmux kill-server
		fi
		# Remove working directory
		rm -rf "$WORKDIR"
	}
	trap _cleanup EXIT

	# Handle stdin: if stdin is not a terminal, save it to a file for the first step
	if [[ ! -t 0 ]]; then
		log "Capturing stdin for first pipeline step..."
		cat >"$WORKDIR/stdin"
	fi

	# Create step directories, serialize commands, create FIFOs
	local i
	for (( i = 0; i < step_count; i++ )); do
		local stepdir="$WORKDIR/steps/$i"
		mkdir -p "$stepdir"

		# Deserialize the step (it's a declare -p output)
		eval "${steps[$i]}"
		# Now current_cmd contains the command
		serialize_array "$stepdir/command" "${current_cmd[@]}"

		# Create FIFO for this step (except the last one)
		if (( i < step_count - 1 )); then
			mkfifo "$stepdir/pipe"
		fi

		dbg "Step $i: ${current_cmd[*]}"
	done

	# Create a file to store the stdout of the last step
	touch "$WORKDIR/stdout"

	# Get the path to this script for reexec
	local self
	self="$(realpath -e "${BASH_SOURCE[0]}")"

	# Determine terminal size
	local term_cols term_lines
	term_cols="$(tput cols 2>/dev/null || echo 80)"
	term_lines="$(tput lines 2>/dev/null || echo 24)"

	# Start tmux server with a dummy command
	log "Starting tmux server..."
	tmux -S "$SOCKET" new-session -d \
		-x "$term_cols" -y "$term_lines" \
		-s "$target" \
		"sleep infinity"

	# Create panes for each step
	# We split horizontally to stack panes vertically
	# Just use session name - tmux will target the current window
	for (( i = 0; i < step_count; i++ )); do
		dbg "Creating pane for step $i"
		_tmux split-window -v \
			-e "$TMUXPIPE_REEXEC_VAR=step" \
			-e "$TMUXPIPE_WORKDIR_VAR=$WORKDIR" \
			-e "$TMUXPIPE_STEP_VAR=$i" \
			"$self"
	done

	# Start the monitor in the first pane
	# Pass step count so monitor knows how many steps to wait for
	_tmux respawn-pane -t "$target.0" -k \
		-e "$TMUXPIPE_REEXEC_VAR=monitor" \
		-e "$TMUXPIPE_WORKDIR_VAR=$WORKDIR" \
		"$self"

	# Re-layout to even-vertical after all panes have been created
	_tmux select-layout even-vertical

	# Set pane titles for clarity
	# Pane 0 is monitor, panes 1..N are steps 0..N-1
	_tmux select-pane -t "$target.0" -T "[monitor]"
	for (( i = 0; i < step_count; i++ )); do
		local -a cmd
		deserialize_array "$WORKDIR/steps/$i/command" cmd
		_tmux select-pane -t "$target.$((i + 1))" -T "[${i}] ${cmd[0]}"
	done

	# Enable pane border status to show titles
	_tmux set-option pane-border-status top
	_tmux set-option pane-border-format \
		' #{pane_index}: #{pane_title} #{?pane_dead,[exit #{pane_dead_status}],}'

	# Set status bar
	_tmux set-option status-left '[tmuxpipe] '
	_tmux set-option status-right ''

	# Focus on the monitor pane
	_tmux select-pane -t "$target.0"

	# Attach to tmux
	log "Attaching to tmux session..."
	_tmux attach-session -t "$target"

	# After detach/exit, collect exit codes
	local pipeline_rc
	pipeline_rc="$(get_pipeline_exit_code)"

	# Cleanup is handled by ltrap
	log "Pipeline completed with exit code $pipeline_rc"

	# Dump last step's stdout
	cat "$WORKDIR/stdout"

	exit "$pipeline_rc"
}

# --- Entry point ---

# Check for reexec mode
if [[ "${!TMUXPIPE_REEXEC_VAR+set}" ]]; then
	mode="${!TMUXPIPE_REEXEC_VAR}"

	if ! [[ ${!TMUXPIPE_WORKDIR_VAR} ]]; then
		die "\$$TMUXPIPE_WORKDIR_VAR not set"
	fi
	WORKDIR="${!TMUXPIPE_WORKDIR_VAR}"
	SOCKET="$WORKDIR/tmux.sock"

	case "$mode" in
	step)
		# Step execution mode
		if ! [[ ${!TMUXPIPE_STEP_VAR} ]]; then
			die "\$$TMUXPIPE_STEP_VAR not set"
		fi
		step="${!TMUXPIPE_STEP_VAR}"
		run_step "$step"
		exit $?
		;;
	monitor)
		# Monitor mode
		run_monitor
		exit $?
		;;
	*)
		die "\$$TMUXPIPE_REEXEC_VAR invalid: ${mode@Q}"
		;;
	esac
fi

# Normal mode: parse arguments and run
parse_args ARGS "$@"

if [[ "${ARG_HELP-}" ]]; then
	_usage
	exit 0
fi

if [[ "${ARG_DEBUG-}" ]]; then
	LIBSH_DEBUG=1
fi

run_main "${ARG_REMAINDER[@]}"
