#!/bin/bash

set -eo pipefail
shopt -s extglob
shopt -s lastpipe

. lib.sh || exit

SRC="$1"
DEST="$2"

if ! [[ -b "$SRC" || -f "$SRC" ]]; then
	die "Bad source: $SRC"
fi

if ! [[ -b "$DEST" || -f "$DEST" || ! -e "$DEST" ]]; then
	die "Bad destination: $DEST"
fi

SRC_REAL="$SRC"
DEST_REAL="$DEST"

function blk_size() {
	blockdev --getsize64 "$1"
}

function file_size() {
	stat -c "%s" "$1"
}

function maybe_size() {
	local dev="$1"
	if [[ -b "$dev" ]]; then
		blk_size "$dev"
	elif [[ -e "$dev" ]]; then
		file_size "$dev"
	else
		echo 0
	fi
}

function maybe_detach() {
	local dev="$1"
	if [[ "$dev" == /dev/loop* ]]; then
		local origin="$(losetup -n -O BACK-FILE "$dev")"
		log "  -> $dev (loop for $origin)"
		losetup -d "$dev"
	else
		log "  -> $dev is not a loop device, not detaching"
	fi
}


function maybe_remove_err() {
	local dev="$1"
	if [[ -b "$dev" ]]; then
		log "  -> $dev, skipping block device"
	else
		log "  -> $dev"
		rm -vf "$dev"
	fi
}

function cleanup() {
	log "detach loop devices"

	maybe_detach "$SRC"
	maybe_detach "$DEST"

	if ! (( success )); then
		log "remove incomplete destination file"
		maybe_remove_err "$DEST_REAL"
	fi
}

success=0
trap cleanup EXIT


function maybe_truncate() {
	local dev="$1"
	local target="$2"
	local dev_size="$(maybe_size "$dev")"
	local target_size="$(maybe_size "$target")"
	if [[ -b "$dev" ]]; then
		if (( dev_size >= target_size )); then
			log "  -> not truncating block device $dev of size $dev_size >= $target_size"
		else
			log "  -> block device $dev is of size $dev < $target_size, cannot proceed"
		fi
	else
		rm -f "$dev"
		truncate --size "$target_size" "$dev"
	fi
}


log "truncate '$DEST' to size of '$SRC'"
maybe_truncate "$DEST" "$SRC"

log "copy partition table"
blkid "$SRC"
SRC_PTTYPE="$(blkid -s PTTYPE -o value "$SRC")"
case "$SRC_PTTYPE" in
dos)
	log "  -> MBR detected -- using sfdisk"
	sfdisk -d "$SRC" | sfdisk "$DEST"
	;;
gpt)
	log "  -> GPT detected -- using sgdisk"
	TEMPFILE="$(mktemp)"
	sgdisk -b "$TEMPFILE" "$SRC"
	sgdisk -l "$TEMPFILE" "$DEST"
	rm -f "$TEMPFILE"
	;;
*)
	log "  -> unknown partition table type '$SRC_PTTYPE'!"
	false
	;;
esac
echo


function maybe_loop() {
	dev="$1"
	if [[ -b "$dev" ]]; then
		log "  -> $dev is block device, skipping"
		echo "$dev"
	else
		local loop=$(losetup -Pf --show "$dev")
		log "  -> $dev ($loop)"
		echo "$loop"
	fi
}

log "setup loop devices..."
SRC="$(maybe_loop "$SRC")"
DEST="$(maybe_loop "$DEST")"


function arg_exists() { [[ -e "$1" ]]; }

log "clone partitions..."
for src_part in "$SRC"?*; do
	# determine source partition number, accounting for two different naming schemas (diskXY and diskXpY)
	partnr="${src_part##$SRC?(p)}"

	# determine destination naming schema
	if arg_exists "${DEST}p"*; then
		dest_part="${DEST}p${partnr}"
	else
		dest_part="${DEST}${partnr}"
	fi

	part_type="$(blkid "$src_part" -o value -s TYPE)"
	echo -n "   -> '$src_part' "

	if [[ "$part_type" ]]; then
		echo -n "of type '$part_type' "
	fi

	echo -n "- "

	if [[ "$part_type" ]] && type -t partclone.$part_type &>/dev/null; then
		echo "using 'partclone.$part_type'"
		"partclone.$part_type" -b -s "$src_part" -O "$dest_part"
	elif [[ "$part_type" == "swap" ]]; then
		echo "recreating swapspace label '$(blkid "$src_part" -o value -s LABEL)' uuid '$(blkid "$src_part" -o value -s UUID)'"
		mkswap \
			-L "$(blkid "$src_part" -o value -s LABEL)" \
			-U "$(blkid "$src_part" -o value -s UUID)" \
			"$dest_part"
	else
		echo "using partclone.dd"
		partclone.dd -s "$src_part" -O "$dest_part"
	fi

	echo
done

success=1
