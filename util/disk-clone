#!/bin/bash

set -eo pipefail
shopt -s extglob
shopt -s lastpipe

. lib.sh || exit

#
# lib.sh logging overrides
#

export LIBSH_LOG_INDENT=0

function indent() {
	(( ++LIBSH_LOG_INDENT ))
}
function unindent() {
	if (( LIBSH_LOG_INDENT > 0 )); then
		(( --LIBSH_LOG_INDENT )) ||:
	fi
}
function unindent_all() {
	LIBSH_LOG_INDENT=0
}
function log() {
	if (( LIBSH_LOG_INDENT )); then
		local i
		local indent=''
		for (( i = 0; i < LIBSH_LOG_INDENT; ++i )); do
			indent+='   '
		done
		_libsh_log "${indent}->" "$LIBSH_LOG_PREFIX" "$*"
	else
		_libsh_log "::" "$LIBSH_LOG_PREFIX" "$*"
	fi
}

function lindent() {
	echo "local LIBSH_LOG_INDENT=\"\$(( LIBSH_LOG_INDENT + 1 ))\""
}

function lunindent() {
	echo "unset LIBSH_LOG_INDENT"
}


#
# functions
#

function blk_size() {
	blockdev --getsize64 "$1"
}


function file_size() {
	stat -c "%s" "$1"
}


function get_size() {
	local dev="$1"
	if [[ -b "$dev" ]]; then
		blk_size "$dev"
	elif [[ -e "$dev" ]]; then
		file_size "$dev"
	else
		echo 0
	fi
}


function exists() {
	[[ -e "$1" ]]
}


function blkid_src() {
	blkid "$src_part" -o value -s "$*"
}


function cleanup_detach() {
	unindent_all
	local dev="$1"
	if [[ "$dev" == /dev/loop* ]]; then
		local origin="$(losetup -n -O BACK-FILE "$dev")"
		log "detaching $dev (loop for $origin)"
		losetup -d "$dev"
	fi
}


function cleanup_remove() {
	unindent_all
	local dev="$1"
	if [[ -e "$dev" && ! -b "$dev" ]]; then
		log "removing $dev"
		rm -f "$dev"
	fi
}

function cleanup_remove_fail() {
	if (( SUCCESS )); then
		return
	fi

	cleanup_remove "$@"
}

function cleanup_close() {
	unindent_all
	local dev="$1"
	if [[ -e "/dev/mapper/$dev" ]]; then
		log "closing LUKS device $dev"
		cryptsetup close "$dev"
	fi
}


function maybe_truncate() {
	eval "$(lindent)"
	local dest="$1"
	local src="$2"
	local dest_size="$(get_size "$dest")"
	local src_size="$(get_size "$src")"
	if [[ -b "$dest" ]]; then
		if (( dest_size >= src_size )); then
			log "block device $dest is of size $dest_size >= $src_size, not truncating"
		else
			log "block device $dest is of size $dest_size < $src_size, aborting"
			exit 1
		fi
	else
		log "removing and replacing regular file $dest"
		ltrap "cleanup_remove_fail '$dest'"
		rm -f "$dest"
		truncate --size "$src_size" "$dest"
	fi
}

function maybe_loop() {
	eval "$(lindent)"
	dev="$1"
	if [[ -b "$dev" ]]; then
		echo "$dev"
	else
		local loop=$(losetup -Pf --show "$dev")
		ltrap "cleanup_detach '$loop'"
		log "$loop for $dev"
		echo "$loop"
	fi
}


#
# main
#

eval "$(globaltraps)"

SUCCESS=0
SRC="$1"
DEST="$2"

if ! [[ -b "$SRC" || -f "$SRC" ]]; then
	die "Bad source: $SRC"
fi

if ! [[ -b "$DEST" || -f "$DEST" || ! -e "$DEST" ]]; then
	die "Bad destination: $DEST"
fi

SRC_REAL="$SRC"
DEST_REAL="$DEST"

log "truncate '$DEST' to size of '$SRC'"
maybe_truncate "$DEST" "$SRC"

log "copy partition table"
indent
SRC_PTTYPE="$(blkid -s PTTYPE -o value "$SRC")"
case "$SRC_PTTYPE" in
dos)
	log "MBR detected -- using sfdisk"
	sfdisk -d "$SRC" | sfdisk "$DEST"
	;;
gpt)
	log "GPT detected -- using sgdisk"
	sgdisk -R "$DEST" "$SRC"
	;;
*)
	log "unknown partition table type '$SRC_PTTYPE'!"
	exit 1
	;;
esac
unindent

log "setup loop devices..."
SRC="$(maybe_loop "$SRC")"
DEST="$(maybe_loop "$DEST")"

# FIXME LUKS2 format parameters are hardcoded
LUKS_FORMAT_CMD=(
	cryptsetup
	luksFormat
	--type luks2
	#--sector-size <autodetermined>
	--cipher aes-xts-plain64
	--key-size 256  # AES-XTS-256 is equivalent to AES-128
	--hash sha256
	--pbkdf argon2id
)
LUKS_OPEN_CMD=(
	cryptsetup
	luksOpen
	--allow-discards
)

function luks_open() {
	local part="$1"
	local name="${part##*/}"
	local uuid="$(blkid "$part" -o value -s UUID)"

	declare -n out="$2"
	out="/dev/mapper/$name"

	ltrap "cleanup_close '$name'"
	loud "When prompted, unlock LUKS volume $part (UUID $uuid) to be opened as $name"
	"${LUKS_OPEN_CMD[@]}" "$part" "$name"
}

function luks_create() {
	local part="$1"
	local name="${part##*/}"

	declare -n out="$2"
	out="/dev/mapper/$name"

	ltrap "cleanup_close '$name'"
	loud "When prompted, enter a passphrase for a new LUKS volume at $part to be opened as $name"
	"${LUKS_FORMAT_CMD[@]}" "$part"
	"${LUKS_OPEN_CMD[@]}" "$part" "$name"
}

function luks_clone() {
	eval "$(lindent)"

	local src_part="$1" dest_part="$2"
	local src_dm dest_dm
	local src_uuid="$(blkid_src UUID)"

	luks_open "$src_part" src_dm
	luks_create "$dest_part" src_dm

	# FIXME hardcode
	clone_partition "$src_dm" "$dest_dm"
}

# $1: src
# $2: dest
function clone_partition() {
	eval "$(lindent)"

	local src_part="$1" dest_part="$2"
	local part_type="$(blkid_src TYPE)"
	local log_msg="cloning '$src_part'"

	log "cloning '$src_part' to '$dest_part'"
	indent

	if [[ "$part_type" ]]; then
		log "type '$part_type'"
	fi

	if [[ "$part_type" ]] && command -v partclone.$part_type &>/dev/null; then
		log "using 'partclone.$part_type'"
		"partclone.$part_type" -b -s "$src_part" -O "$dest_part"
	elif [[ "$part_type" == "swap" ]]; then
		log "recreating swapspace label '$(blkid_src LABEL)' uuid '$(blkid_src UUID)'"
		mkswap \
			-L "$(blkid_src LABEL)" \
			-U "$(blkid_src UUID)" \
			"$dest_part"
	elif  [[ "$part_type" == "crypto_LUKS" ]]; then
		log "entering LUKS container"
		luks_clone "$src_part" "$dest_part"
	else
		log "using partclone.dd"
		partclone.dd -s "$src_part" -O "$dest_part"
	fi
}

log "clone partitions..."
for src_part in "$SRC"?*; do
	# determine source naming convention (diskXY vs diskXpY) and partition number
	if exists "${DEST}p"[0-9]*; then
		partnr="${src_part##${SRC}p}"
		dest_part="${DEST}p${partnr}"
	else
		partnr="${src_part##${SRC}}"
		dest_part="${DEST}${partnr}"
	fi

	clone_partition "$src_part" "$dest_part"
done

SUCCESS=1
