#!/bin/bash

set -eo pipefail
shopt -s lastpipe
. lib.sh

_usage() {
	cat <<EOF
Usage: $0 [--guid GUID-FILE] [--with KEY-DIR] [--as PK|KEK|db] INPUTS... [-o] OUTPUT
       $0 [--guid GUID-FILE] [--with KEY-DIR] [--as PK|KEK|db]            -o  OUTPUT

GUID-FILE must contain the signature owner GUID (specified via a file rather
than immediately on the command line).

KEY-DIR must contain a single *.key file (used as the signing private key)
and a single *.pem file (used as the signing public key/certificate).

INPUTS may be one or more ESL files, which will be combined, or omitted, in
which case an empty authenticated update will be created.

OUTPUT may be specified as either the last positional argument
or using the \`-o\` flag.
EOF
}


#
# args
#

declare -A _args=(
	[-h|--help]=ARG_USAGE
	[--with:]=ARG_WITH
	[--as:]=ARG_AS
	[-a|--append]=ARG_APPEND
	[-o|--output]=ARG_OUTPUT
	[-g|--guid]=ARG_GUID
	[--]=ARGS
)
parse_args _args "$@" || usage
[[ ! $ARG_USAGE ]] || usage

if [[ ${ARG_GUID+set} && ! -f $ARG_GUID ]]; then
	usage "Invalid --guid=${ARG_GUID@Q}: file does not exist"
fi

if ! [[ ${ARG_WITH+set} ]]; then
	usage "Invlaid usage: --with= must be set"
elif ! [[ -d $ARG_WITH ]]; then
	usage "Invalid --with=${ARG_WITH@Q}: directory does not exist"
fi
with_keys=( "$ARG_WITH"/*.key )
with_crts=( "$ARG_WITH"/*.pem )
if ! (( ${#with_keys[@]} == 1 )); then
	usage "Invalid --with=${ARG_WITH@Q}: found ${#with_keys[@]} != 1 private keys ($(join ', ' "${with_keys[@]}"))"
fi
if ! (( ${#with_crts[@]} == 1 )); then
	usage "Invalid --with=${ARG_WITH@Q}: found ${#with_crtcrts} != 1 certificates ($(join ', ' "${with_crts[@]}"))"
fi

case "$ARG_AS" in
PK|KEK|db) ;;
'') usage "Invalid usage: --as= must be set" ;;
*) usage "Invalid --as=${ARG_AS@Q}: expected one of PK, KEK, db" ;;
esac

if ! [[ ${ARG_OUTPUT+set} ]]; then
	if ! (( ${#ARGS[@]} >= 2 )); then
		usage "Invalid usage: --output not set and less than 2 positional arguments"
	fi
	ARG_OUTPUT="${ARGS[-1]}"
	ARG_INPUTS=( "${ARGS[@]:0:${#ARGS[@]}-1}" )
else
	if ! (( ${#ARGS[@]} )); then
		ARG_INPUTS=( /dev/null )
	fi
fi

log "Signing key:  ${with_keys@Q}"
log "Signing cert: ${with_crts@Q}"
log "Signing as:   $ARG_AS"
log "Inputs:       $(join ', ' "${ARG_INPUTS[@]@Q}")"
log "Output:       ${ARG_OUTPUT@Q}"
if [[ ${ARG_APPEND+set} ]]; then
log "Append:       yes"
else
log "Append:       no"
fi


#
# main
#

eval "$(globaltraps)"

args=()

if [[ ${ARG_GUID+set} ]]; then
	args+=( -g "$(< "$ARG_GUID")" )
fi

args+=(
	-k "$with_keys"
	-c "$with_crts"
)

if [[ ${ARG_APPEND+set} ]]; then
	args+=( -a )
fi

if (( ${#ARG_INPUTS[@]} > 1 )); then
	log "Multiple inputs, concatenating"
	ARG_INPUT_COMBINED="$(mktemp --tmpdir efisign.XXXXXX)"
	ltrap "rm ${ARG_INPUT_COMBINED@Q}"
	set -x
	cat "${ARG_INPUTS[@]}" | tee "$ARG_INPUT_COMBINED" >/dev/null
	{ set +x; } &>/dev/null
else
	ARG_INPUT_COMBINED="$ARG_INPUTS"
fi

set -x
sign-efi-sig-list \
	"${args[@]}" \
	"$ARG_AS" \
	"$ARG_INPUT_COMBINED" \
	"$ARG_OUTPUT"
{ set +x; } &>/dev/null
