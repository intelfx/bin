#!/bin/bash -e

set -eo pipefail
shopt -s lastpipe

# shellcheck source=../lib/lib.sh
. lib.sh


#
# essential functions, wrappers
#

SYSTEMD_USER_ARGS=()
FUSE_USER_ARGS=()
if [[ $(id -u) != 0 ]]; then
	SYSTEMD_USER_ARGS+=( --user )
	FUSE_USER_ARGS=( -o allow_root -o idmap=user )
else
	FUSE_USER_ARGS=( -o allow_other )
fi

systemctl() { Trace command systemctl "${SYSTEMD_USER_ARGS[@]}" "$@"; }


#
# args
#

TARGET="$1"
ARGS=( "${@:2}" )

case "${ARGS[0]}" in
/*|./*|../*)
	MOUNTPOINT="${ARGS[0]}"
	ARGS=( "${ARGS[@]:1}" )
	;;
esac


#
# ssh defaults
#

SSH_ARGS=(
	"${ARGS[@]}"
	-o BatchMode=yes
	-o ServerAliveInterval=15
	-o ControlMaster=auto
	# ideally, we'd like to enable ControlPersist here to reuse the
	# short-lived connection we open when running `whoami`.
	# however, this makes the ssh process spawned while running `whoami`
	# run in background indefinitely.
	# we do not want to leave arbitrary background processes outside of the
	# `sshfs-*.service` unit we create, so don't do this.
	# -o ControlPersist=1
	-o ControlPath="$HOME/.ssh/sock-%C"
)

SSHFS_ARGS=(
	"${SSH_ARGS[@]}"
	"${FUSE_USER_ARGS[@]}"
	-o transform_symlinks
	-o reconnect
	-o max_conns=8
	-o dir_cache=yes
	-o dcache_max_size=$((1024*1024))
	-o dcache_timeout=600
	-o dcache_stat_timeout=600
	-o dcache_link_timeout=600
	-o dcache_dir_timeout=600
	-o dcache_clean_interval=60
	-o dcache_min_clean_interval=10
)

if [[ "$TARGET" =~ ([^@]+@)?([^:]*)(:.+)? ]]; then
	USER="${BASH_REMATCH[1]%'@'}"
	HOST="${BASH_REMATCH[2]}"
	DIR="${BASH_REMATCH[3]#':'}"
else
	die "Cannot parse sshfs target: '$1'"
fi

USERHOST="${USER:+$USER@}${HOST}"
SYMBOLIC_USER="$(ssh "${SSH_ARGS[@]}" "$USERHOST" 'whoami')"
SYMBOLIC_USERHOST="${SYMBOLIC_USER}@${HOST}"

if [[ -z "$DIR" ]]; then
	SYMBOLIC_DIR="~"
elif ! [[ $DIR == /* ]]; then
	SYMBOLIC_DIR="~/$DIR"
else
	SYMBOLIC_DIR="$DIR"
fi

if ! [[ ${MOUNTPOINT+set} ]]; then
	MOUNTPOINT="$HOME/mnt/${SYMBOLIC_USERHOST}/${SYMBOLIC_DIR##/}"
fi
mkdir -p "$MOUNTPOINT"

UNIT="sshfs-$(systemd-escape "$SYMBOLIC_USER")-$(systemd-escape "$HOST")-$(systemd-escape "$DIR").service"
ACTIVE="$(systemctl is-active "$UNIT" || true)"
case "$ACTIVE" in
inactive)
	;;
failed)
	systemctl reset-failed "$UNIT"
	;;
active)
	systemctl status "$UNIT"
	exit
	;;
*)
	systemctl status "$UNIT"
	die "Invalid unit state for '$UNIT': '$ACTIVE'"
	;;
esac

SYSTEMD_RUN_ARGS=()
if [[ ${SSH_AUTH_SOCK+set} ]]; then
	SYSTEMD_RUN_ARGS+=( -E SSH_AUTH_SOCK )
fi

set -x
exec systemd-run \
	"${SYSTEMD_USER_ARGS[@]}" \
	--unit "$UNIT" \
	-p Type=forking \
	"${SYSTEMD_RUN_ARGS[@]}" \
	sshfs \
		"$USERHOST:$DIR" \
		"$MOUNTPOINT" \
		"${SSHFS_ARGS[@]}" \
